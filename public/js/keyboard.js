// Generated by CoffeeScript 1.4.0
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

window.onload = (function() {
  var Keyboard, RUN_TESTS, playingKeyboard;
  RUN_TESTS = false;
  Keyboard = function() {
    var MIDI_keys, add_background, add_cabinet, add_camera, add_keyboard, add_keys, add_lights, animate, b_song, c_song, camera, canvas, checkScaleDegree, checkTriad, chords, chromatic_scale, constant, convertKeyIndex, createNoteLabels, createScaleDegrees, createScene, create_materials, create_pointer, create_pointer_labels, create_pointers, current_pointer, current_scale, current_scale_degree, current_triad_name, event, fail_song, generateScale, getHalfStep, getKeyPlayed, getMIDIkey, getNextNote, getNoteLabel, getObject, getWholeStep, hidePointer, highlighted_key, initialize_pointers, isActive, isSameChord, isValidMajorChord, key_played, layout, major_triad_names, material, mousedown, mouseup, nextWhiteKey, note_labels, objects, parseKeyObject, playB, playC, playChord, playFail, playNote, playQ, playScale, pointers, practice_keys, pressKey, q_song, randomlySelectNewName, releaseKey, render, renderer, root_selected, scale_degree_names, scene, screen, selectScaleDegree, selectTriad, showPointer, singAlong, spacingToNextBlackKey, spacingToNextWhiteKey, spot_light, traceRayIntoScene, x, _i;
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(73, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    canvas = {
      height: window.innerHeight / 2,
      width: window.innerWidth * 0.95
    };
    renderer.setSize(canvas.width, canvas.height);
    screen = document.getElementById('keyboard').appendChild(renderer.domElement);
    MIDI.setVolume(0, 127);
    q_song = document.getElementById("questionable");
    b_song = document.getElementById("bead");
    c_song = document.getElementById("ceg");
    fail_song = document.getElementById("the_fail_song");
    add_camera = function() {
      camera.position.x = 0;
      camera.position.y = -60;
      camera.position.z = 125;
      return camera.lookAt(new THREE.Vector3(0, 5, 0));
    };
    spot_light = null;
    add_lights = function() {
      var ambient_light, directional_light, point_light;
      ambient_light = new THREE.AmbientLight(0x808080);
      scene.add(ambient_light);
      directional_light = new THREE.DirectionalLight(0x404040, 0.6);
      directional_light.position.set(0, 400, -60);
      scene.add(directional_light);
      point_light = new THREE.PointLight(0xffffff, 0.45, 1000);
      point_light.position.set(-45, 15, 80);
      scene.add(point_light);
      spot_light = new THREE.SpotLight({
        color: 0xffffff,
        intensity: 0.95
      });
      spot_light.position.set(0, 400, 500);
      spot_light.target.position.set(0, -50, -50);
      spot_light.exponent = 10.0;
      return scene.add(spot_light);
    };
    add_background = function() {
      var background;
      background = new THREE.Mesh(new THREE.PlaneGeometry(5000, 5000), new THREE.MeshBasicMaterial({
        color: 0x000000
      }));
      background.position.z = -500;
      return scene.add(background);
    };
    nextWhiteKey = function(key) {
      if (key === "C") {
        return "D";
      }
      if (key === "D") {
        return "E";
      }
      if (key === "E") {
        return "F";
      }
      if (key === "F") {
        return "G";
      }
      if (key === "G") {
        return "A";
      }
      if (key === "A") {
        return "B";
      }
      if (key === "B") {
        return "C";
      }
    };
    if (RUN_TESTS) {
      test('nextWhiteKey(key) - Returns the next white key', function() {
        var index, key, keys, _i, _len, _results;
        keys = ["C", "D", "E", "F", "G", "A", "B", "C"];
        _results = [];
        for (index = _i = 0, _len = keys.length; _i < _len; index = ++_i) {
          key = keys[index];
          if (index !== (keys.length - 1)) {
            _results.push(equal(nextWhiteKey(key), keys[index + 1], keys[index + 1] + ' follows ' + key));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    }
    spacingToNextWhiteKey = function(key, gap_length) {
      var delta;
      delta = getDelta(key);
      if (key === "C" || key === "F") {
        return (delta / 2 + (24 - delta)) + gap_length + keyCenter(nextWhiteKey(key));
      } else if (key === "B" || key === "E") {
        return (24 - delta) / 2 + gap_length + keyCenter(nextWhiteKey(key));
      } else if (key === "D" || key === "A") {
        return (24 - delta[0] - delta[1]) / 2 + delta[1] + gap_length + keyCenter(nextWhiteKey(key));
      } else {
        return (24 - delta[0] - delta[1]) / 2 + delta[1] + gap_length + keyCenter(nextWhiteKey(key));
      }
    };
    spacingToNextBlackKey = function(key, gap_length, blk_key_width) {
      var delta;
      if (key === "B" || key === "E") {
        return 0;
      }
      delta = getDelta(key);
      if (key === "C" || key === "F") {
        return delta / 2 + gap_length / 2 + blk_key_width / 2;
      } else {
        return (24 - delta[0] - delta[1]) / 2 + gap_length / 2 + blk_key_width / 2;
      }
    };
    constant = {
      white_key_height: 100,
      white_key_width: 24,
      black_key_height: 60,
      black_key_width: 14,
      key_spacing: 1.1,
      key_offset: -73
    };
    key_played = '';
    highlighted_key = '';
    material = {
      ivory: 0,
      black: 0,
      key_pressed: 0,
      cabinet: 0,
      banner: 0,
      pointer: 0
    };
    objects = {
      white_key: [],
      black_key: []
    };
    note_labels = {
      white: [],
      black: []
    };
    layout = {
      white_keys: ["F", "G", "A", "B", "C", "D", "E", "F", "G", "A", "B", "C", "D", "E", "F", "G", "A", "B"],
      black_keys: ["F#/Gb", "G#/Ab", "A#/Bb", "C#/Db", "D#/Eb"]
    };
    chords = [["C", "E", "G"], ["D", "F#/Gb", "A"], ["E", "G#/Ab", "B"], ["F", "A", "C"], ["G", "B", "D"], ["A", "C#/Db", "E"], ["B", "D#/Eb", "F#/Gb"], ["C#/Db", "F", "G#/Ab"], ["D#/Eb", "G", "A#/Bb"], ["F#/Gb", "A#/Bb", "C#/Db"], ["G#/Ab", "C", "D#/Eb"], ["A#/Bb", "D", "F"]];
    practice_keys = [];
    current_triad_name = null;
    major_triad_names = {
      white: [],
      black: []
    };
    root_selected = null;
    current_scale_degree = null;
    current_scale = [];
    scale_degree_names = [];
    current_pointer = null;
    pointers = [];
    event = 0;
    create_materials = function() {
      var cab_specular, specular_color;
      material.ivory = new THREE.MeshPhongMaterial({
        color: 0xfaf7c4,
        side: THREE.DoubleSide
      });
      material.ivory.ambient.copy(material.ivory.color);
      material.banner = new THREE.MeshPhongMaterial({
        emissive: 0x000000,
        side: THREE.DoubleSide
      });
      material.banner.ambient.copy(material.banner.color);
      specular_color = new THREE.Color();
      specular_color.setRGB(0.95, 0.95, 0.95);
      material.black = new THREE.MeshPhongMaterial({
        color: 0x000000,
        side: THREE.DoubleSide,
        shininess: 30,
        specular: specular_color
      });
      material.black.ambient.copy(material.black.color);
      cab_specular = new THREE.Color();
      cab_specular.setRGB(0.9, 0.9, 0.9);
      material.cabinet = new THREE.MeshPhongMaterial({
        shininess: 70,
        color: 0x996633,
        map: THREE.ImageUtils.loadTexture("textures/wood.jpg"),
        specular: cab_specular
      });
      material.cabinet.ambient.copy(material.cabinet.color);
      material.key_pressed = new THREE.MeshFaceMaterial([
        new THREE.MeshLambertMaterial({
          emissive: 0x0000ff,
          color: 0xff0000,
          side: THREE.DoubleSide,
          shininess: 40
        })
      ]);
      material.pointer = new THREE.MeshPhongMaterial({
        shininess: 100,
        side: THREE.DoubleSide,
        color: 0x007ade
      });
      return material.pointer.ambient.copy(material.pointer.color);
    };
    add_keys = function(keyboard) {
      var S, b_index, black_key_geometry, black_key_position, index, key, white_key_geometry, white_key_position, _i, _len, _ref, _results;
      white_key_position = 0;
      b_index = 0;
      white_key_geometry = 0;
      _ref = layout.white_keys;
      _results = [];
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        key = _ref[index];
        if (__indexOf.call("CF", key) >= 0) {
          white_key_geometry = geometryOfCF(key, constant.white_key_height, constant.black_key_height, constant.black_key_width);
        } else if (__indexOf.call("BE", key) >= 0) {
          white_key_geometry = geometryOfBE(key, constant.white_key_height, constant.black_key_height, constant.black_key_width);
        } else {
          white_key_geometry = geometryOfDGA(key, constant.white_key_height, constant.black_key_height, constant.black_key_width);
        }
        objects.white_key[index] = new THREE.Mesh(white_key_geometry, material.ivory);
        objects.white_key[index].id = 'white ' + index;
        objects.white_key[index].name = layout.white_keys[index];
        objects.white_key[index].position.x = white_key_position + constant.key_offset;
        objects.white_key[index].scale.x = 1;
        objects.white_key[index].scale.z = 1.75;
        keyboard.add(objects.white_key[index]);
        black_key_position = spacingToNextBlackKey(key, constant.key_spacing, constant.black_key_width) / 3;
        if (black_key_position > 0) {
          black_key_geometry = blackKeyGeometry(constant.black_key_height, constant.black_key_width);
          objects.black_key[b_index] = new THREE.Mesh(black_key_geometry, material.black);
          objects.black_key[b_index].id = 'black ' + b_index;
          objects.black_key[b_index].name = layout.black_keys[convertKeyIndex('black', b_index)];
          objects.black_key[b_index].position.x = objects.white_key[index].position.x + black_key_position;
          objects.black_key[b_index].position.y = -constant.black_key_height / 2 / 3;
          objects.black_key[b_index].position.z = 1;
          S = 1;
          objects.black_key[b_index].scale.x = 1;
          objects.black_key[b_index].scale.y = S;
          objects.black_key[b_index].scale.z = 1.55;
          keyboard.add(objects.black_key[b_index]);
          b_index = b_index + 1;
        }
        _results.push(white_key_position = white_key_position + spacingToNextWhiteKey(key, constant.key_spacing) / 3);
      }
      return _results;
    };
    add_cabinet = function(keyboard) {
      var brand_name, brand_name_geometry, cabinet, cabinet_back, cabinet_back_geometry, cabinet_bottom, cabinet_bottom_geometry, cabinet_height, cabinet_width;
      cabinet = new THREE.Object3D();
      cabinet_height = 200;
      cabinet_width = 60;
      cabinet_bottom_geometry = new THREE.BeveledBlockGeometry(cabinet_height, cabinet_width, constant.black_key_height * 0.15, 0.5);
      cabinet_bottom = new THREE.Mesh(cabinet_bottom_geometry, material.cabinet);
      cabinet_bottom.translateY(-12);
      cabinet.add(cabinet_bottom);
      cabinet_back = new THREE.Object3D();
      cabinet_back_geometry = new THREE.BeveledBlockGeometry(cabinet_height, cabinet_width / 0.9, constant.black_key_height * 0.15, 0.5);
      cabinet_back = new THREE.Mesh(cabinet_back_geometry, material.cabinet);
      brand_name = new THREE.Object3D();
      brand_name_geometry = new THREE.TextGeometry("Mineway", {
        size: 16,
        height: 10,
        curveSegments: 20,
        font: "optimer",
        weight: "bold",
        style: "normal",
        bevelThickness: 0.5,
        bevelSize: 0.3,
        bevelEnabled: true,
        material: 0,
        extrudeMaterial: 1
      });
      brand_name = new THREE.Mesh(brand_name_geometry, material.cabinet);
      brand_name.translateX(-38);
      brand_name.translateY(7);
      cabinet_back.add(brand_name);
      cabinet_back.translateY(10);
      cabinet_back.translateZ(15);
      cabinet_back.rotation.x = Math.PI / 3.7;
      cabinet.add(cabinet_back);
      cabinet.translateZ(-4);
      cabinet.id = 'cabinet';
      return keyboard.add(cabinet);
    };
    add_keyboard = function() {
      var black_MIDI_keys_in_first_octave, keyboard, position, white_MIDI_keys_in_first_octave, x, _i;
      keyboard = new THREE.Object3D();
      keyboard.id = 'keyboard';
      scene.add(keyboard);
      black_MIDI_keys_in_first_octave = [54, 56, 58, 61, 63];
      white_MIDI_keys_in_first_octave = [];
      for (x = _i = 53; _i <= 64; x = ++_i) {
        if (__indexOf.call(black_MIDI_keys_in_first_octave, x) < 0) {
          white_MIDI_keys_in_first_octave.push(x);
        }
      }
      add_keys(keyboard);
      add_cabinet(keyboard);
      position = function(keyboard) {
        keyboard.rotation.x = -Math.PI / 6.5;
        keyboard.translateZ(0);
        return keyboard.translateY(-12);
      };
      position(keyboard);
      return create_pointer(keyboard);
    };
    create_pointer = function(keyboard) {
      var pointer, pointer_body, pointer_head;
      pointer = new THREE.Object3D();
      pointer.id = 'pointer';
      pointer_body = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 15, 10, 10, false), material.pointer);
      pointer_body.id = 'body';
      pointer.add(pointer_body);
      pointer_head = new THREE.Mesh(new THREE.CylinderGeometry(0, 5, 17, 10, 10, false), material.pointer);
      pointer_head.rotation.x = Math.PI;
      pointer_head.position.y = -(15 / 2 + 7 / 2);
      pointer_head.id = 'head';
      pointer.add(pointer_head);
      return keyboard.add(pointer);
    };
    create_pointer_labels = function() {
      var _ref, _ref1;
      _ref = createNoteLabels(layout.white_keys.slice(0, 7), note_labels.white, major_triad_names.white, 5), note_labels.white = _ref[0], major_triad_names.white = _ref[1];
      return _ref1 = createNoteLabels(layout.black_keys, note_labels.black, major_triad_names.black, 20), note_labels.black = _ref1[0], major_triad_names.black = _ref1[1], _ref1;
    };
    initialize_pointers = function(color, notes, labels) {
      var index, note, pointer_body, pointer_head, _i, _len, _results;
      _results = [];
      for (index = _i = 0, _len = notes.length; _i < _len; index = ++_i) {
        note = notes[index];
        pointers[index] = new THREE.Object3D();
        pointers[index].id = note;
        pointers[index].name = 'pointer';
        pointer_body = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 15, 10, 10, false), material.pointer);
        pointer_body.id = 'body';
        pointers[index].add(pointer_body);
        pointer_head = new THREE.Mesh(new THREE.CylinderGeometry(0, 5, 17, 10, 10, false), material.pointer);
        pointer_head.rotation.x = Math.PI;
        pointer_head.position.y = -(15 / 2 + 7 / 2);
        pointer_head.id = 'head';
        pointers[index].add(pointer_head);
        _results.push(pointers[index].add(labels[convertKeyIndex(color, index)]));
      }
      return _results;
    };
    create_pointers = function() {
      create_pointer_labels();
      initialize_pointers('white', layout.white_keys, note_labels.white);
      return initialize_pointers('black', layout.black_keys, note_labels.black);
    };
    createScene = function() {
      create_materials();
      create_pointers();
      scale_degree_names = createScaleDegrees(scale_degree_names);
      add_camera();
      add_background();
      add_lights();
      return add_keyboard();
    };
    MIDI_keys = {
      delay: 1 / 2,
      velocity: 127,
      black_in_first_octave: [54, 56, 58, 61, 63],
      white_in_first_octave: []
    };
    for (x = _i = 53; _i <= 64; x = ++_i) {
      if (__indexOf.call(MIDI_keys.black_in_first_octave, x) < 0) {
        MIDI_keys.white_in_first_octave.push(x);
      }
    }
    MIDI.setVolume(0, 127);
    getMIDIkey = function(key_color, key_index) {
      var k;
      if (key_color === 'black') {
        k = Math.floor(key_index / 5);
        return MIDI_keys.black_in_first_octave[key_index - 5 * k] + 12 * k;
      } else {
        k = Math.floor(key_index / 7);
        return MIDI_keys.white_in_first_octave[key_index - 7 * k] + 12 * k;
      }
    };
    if (RUN_TESTS) {
      test('getMIDIkey(key_color, key_index) - Returns the MIDI key number', function() {
        equal(getMIDIkey('white', 0), 53, 'F3 key');
        equal(getMIDIkey('black', 0), 54, 'F#3 key');
        equal(getMIDIkey('white', 4), 60, 'C4 key - middle C');
        equal(getMIDIkey('white', 9), 69, 'A#4 key');
        return equal(getMIDIkey('white', 17), 83, 'B5 key');
      });
    }
    convertKeyIndex = function(key_color, key_index) {
      var base, k;
      base = 7;
      if (key_color === 'black') {
        base = 5;
      }
      k = Math.floor(key_index / base);
      return key_index - base * k;
    };
    if (RUN_TESTS) {
      test('convertKeyIndex(key_color, key_index) - Returns the position of a key given its color, base 7 for white keys, base 5 for black keys', function() {
        equal(convertKeyIndex('white', 0), 0, 'The first white key F3 has white key index 0');
        equal(convertKeyIndex('white', 8), 1, 'The eighth white key G4 has white key index 1');
        equal(convertKeyIndex('black', 0), 0, 'The first black key F#3 has black key index 0');
        equal(convertKeyIndex('black', 5), 0, 'The fifth black key has black key index 0');
        equal(convertKeyIndex('black', 2), 2, 'The third black key C#4 has black key index 2');
        return equal(convertKeyIndex('black', 7), 2, 'The eighth black key A#4 has black key index 2');
      });
    }
    createNoteLabels = function(notes, buffer, majorBuffer, offset) {
      var black, i, label_geometry, note, _j, _len;
      if (__indexOf.call(notes[0], "#") >= 0) {
        black = true;
      }
      i = 0;
      for (_j = 0, _len = notes.length; _j < _len; _j++) {
        note = notes[_j];
        label_geometry = new THREE.TextGeometry(note, {
          size: 14,
          height: 3,
          curveSegments: 30,
          font: 'optimer',
          weight: 'normal',
          style: 'normal',
          bevelThickness: 0.5,
          bevelSize: 0.3,
          bevelEnabled: true,
          material: 0,
          extrudeMaterial: 1
        });
        buffer[i] = new THREE.Mesh(label_geometry, material.pointer);
        buffer[i].position.x -= offset;
        buffer[i].position.y += 12;
        buffer[i].rotation.x = -20 * Math.PI / 180;
        buffer[i].id = note;
        label_geometry = new THREE.TextGeometry(note + " Major Triad", {
          size: 18,
          height: 8,
          curveSegments: 30,
          font: 'optimer',
          weight: 'normal',
          style: 'normal',
          bevelThickness: 0.5,
          bevelSize: 0.3,
          bevelEnabled: true,
          material: 0,
          extrudeMaterial: 1
        });
        majorBuffer[i] = new THREE.Mesh(label_geometry, material.pointer);
        majorBuffer[i].id = note;
        majorBuffer[i].scale.x = 1.0;
        majorBuffer[i].scale.y = 1.0;
        majorBuffer[i].translateX(-60);
        if (black) {
          majorBuffer[i].translateX(-30);
        }
        majorBuffer[i].translateY(90);
        majorBuffer[i].rotation.x = 45 * Math.PI / 180;
        i += 1;
      }
      return [buffer, majorBuffer];
    };
    createScaleDegrees = function(buffer) {
      var degree, i, label_geometry, scale, _j, _len;
      scale = [[2, "2nd"], [3, "3rd"], [4, "4th"], [5, "5th"], [6, "6th"], [7, "7th"], [2, "9th"], [4, "11th"], [6, "13th"]];
      i = 0;
      for (_j = 0, _len = scale.length; _j < _len; _j++) {
        degree = scale[_j];
        label_geometry = new THREE.TextGeometry(degree[1] + " note", {
          size: 18,
          height: 8,
          curveSegments: 30,
          font: 'optimer',
          weight: 'normal',
          style: 'normal',
          bevelThickness: 0.5,
          bevelSize: 0.3,
          bevelEnabled: true,
          material: 0,
          extrudeMaterial: 1
        });
        buffer[i] = new THREE.Mesh(label_geometry, material.pointer);
        buffer[i].id = degree[0];
        buffer[i].name = degree[1];
        buffer[i].scale.x = 1.0;
        buffer[i].scale.y = 1.0;
        buffer[i].translateY(90);
        buffer[i].translateX(-40);
        buffer[i].rotation.x = 45 * Math.PI / 180;
        i += 1;
      }
      return buffer;
    };
    getNoteLabel = function(key_color, key_index) {
      var index;
      index = convertKeyIndex(key_color, key_index);
      if (key_color === 'black') {
        return note_labels.black[index];
      } else {
        return note_labels.white[index];
      }
    };
    chromatic_scale = ["A", "A#/Bb", "B", "C", "C#/Db", "D", "D#/Eb", "E", "F", "F#/Gb", "G", "G#/Ab"];
    getWholeStep = function(note) {
      var index, scale_note, _j, _len;
      if (note === "G" || note === "G#/Ab") {
        if (note === "G") {
          return "A";
        }
        return "A#/Bb";
      }
      for (index = _j = 0, _len = chromatic_scale.length; _j < _len; index = ++_j) {
        scale_note = chromatic_scale[index];
        if (note === scale_note) {
          return chromatic_scale[index + 2];
        }
      }
    };
    getHalfStep = function(note) {
      var index, scale_note, _j, _len;
      if (note === "G#/Ab") {
        return "A";
      }
      for (index = _j = 0, _len = chromatic_scale.length; _j < _len; index = ++_j) {
        scale_note = chromatic_scale[index];
        if (note === scale_note) {
          return chromatic_scale[index + 1];
        }
      }
    };
    getNextNote = function(note, step) {
      if (step === 'whole_step') {
        return getWholeStep(note);
      }
      if (step === 'half_step') {
        return getHalfStep(note);
      }
    };
    parseKeyObject = function(key_played) {
      var key_color, key_index, key_info;
      key_info = key_played.split(' ');
      key_color = key_info[0];
      key_index = parseInt(key_info[1]);
      return [key_color, key_index];
    };
    playScale = function(key_color, key_index) {
      var delay, half_step_offset, index, midi_start, _j, _len, _ref, _results;
      current_scale.push(current_scale[0]);
      midi_start = getMIDIkey(key_color, key_index);
      if (key_color === 'white') {
        if (midi_start > 71) {
          midi_start = midi_start - 7;
        }
      } else {
        if (midi_start > 70) {
          midi_start = midi_start - 7;
        }
      }
      delay = 0.5;
      _ref = [0, 2, 4, 5, 7, 9, 11, 12];
      _results = [];
      for (index = _j = 0, _len = _ref.length; _j < _len; index = ++_j) {
        half_step_offset = _ref[index];
        _results.push(playNote(midi_start + half_step_offset, index / 16 + delay));
      }
      return _results;
    };
    pressKey = function(key_played, play_note) {
      var key_color, key_index, _ref;
      if (key_played === '') {
        return;
      }
      _ref = parseKeyObject(key_played), key_color = _ref[0], key_index = _ref[1];
      if (key_color === 'white') {
        objects.white_key[key_index].material = material.pointer;
        objects.white_key[key_index].rotation.x = Math.PI / 20;
        showPointer(objects.white_key[key_index], key_color, key_index);
      } else {
        objects.black_key[key_index].material = material.pointer;
        objects.black_key[key_index].rotation.x = Math.PI / 10;
        showPointer(objects.black_key[key_index], key_color, key_index);
      }
      if (play_note) {
        return playNote(getMIDIkey(key_color, key_index), 0);
      }
    };
    releaseKey = function() {
      var key_color, key_index, _ref;
      if (key_played === '') {
        return;
      }
      hidePointer();
      _ref = parseKeyObject(key_played), key_color = _ref[0], key_index = _ref[1];
      if (key_color === 'white') {
        objects.white_key[key_index].material = material.ivory;
        objects.white_key[key_index].rotation.x = 0;
      } else {
        objects.black_key[key_index].material = material.black;
        objects.black_key[key_index].rotation.x = 0;
      }
      return current_pointer = null;
    };
    generateScale = function(tonic) {
      var index, key_index, key_info, note_name, notes_in_scale, object, scale, step, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      _ref = parseKeyObject(tonic), key_info = _ref[0], key_index = _ref[1];
      releaseKey(tonic);
      _ref1 = objects.white_key;
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        object = _ref1[_j];
        if (object.id === tonic) {
          note_name = object.name;
        }
      }
      if (!note_name) {
        _ref2 = objects.black_key;
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          object = _ref2[_k];
          if (object.id === root) {
            note_name = object.name;
          }
        }
      }
      notes_in_scale = [tonic];
      scale = [];
      scale[0] = note_name;
      _ref3 = ['whole_step', 'whole_step', 'half_step', 'whole_step', 'whole_step', 'whole_step'];
      for (index = _l = 0, _len2 = _ref3.length; _l < _len2; index = ++_l) {
        step = _ref3[index];
        scale[index + 1] = getNextNote(scale[index], step);
      }
      return scale;
    };
    showPointer = function(key, key_color, key_index) {
      var pointer, _j, _len;
      for (_j = 0, _len = pointers.length; _j < _len; _j++) {
        pointer = pointers[_j];
        if ((pointer.id === getNoteLabel(key_color, key_index).id) && (pointer.name === 'pointer')) {
          current_pointer = pointer;
        }
      }
      current_pointer.position.x = key.position.x;
      if (key_color === 'black') {
        current_pointer.position.y = key.position.y;
        current_pointer.position.z = 30;
      } else {
        current_pointer.position.y = key.position.y - constant.white_key_height / 4.0;
        current_pointer.position.z = 20;
      }
      current_pointer.rotation.x = 75 * Math.PI / 180;
      current_pointer.scale.set(0.65, 0.65, 0.65);
      return getObject('keyboard').add(current_pointer);
    };
    hidePointer = function() {
      getObject('keyboard').remove(current_pointer);
      return current_pointer = null;
    };
    traceRayIntoScene = function(x_coordinate, y_coordinate) {
      var bounding_rectangle, direction, element, projector, ray, vector;
      element = renderer.domElement;
      bounding_rectangle = element.getBoundingClientRect();
      screen = {
        x: (x_coordinate - bounding_rectangle.left) * (element.width / bounding_rectangle.width),
        y: (y_coordinate - bounding_rectangle.top) * (element.height / bounding_rectangle.height)
      };
      vector = new THREE.Vector3((screen.x / canvas.width) * 2 - 1, -(screen.y / canvas.height) * 2 + 1, 0.5);
      projector = new THREE.Projector();
      projector.unprojectVector(vector, camera);
      direction = vector.sub(camera.position).normalize();
      return ray = new THREE.Raycaster(camera.position, direction);
    };
    getKeyPlayed = function(event) {
      var closest_object, distances, intersections, ray, shortest_distance, y, _j, _len, _ref;
      intersections = [];
      ray = traceRayIntoScene(event.clientX, event.clientY);
      intersections = ray.intersectObjects(objects.black_key);
      _ref = ray.intersectObjects(objects.white_key);
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        x = _ref[_j];
        intersections.push(x);
      }
      distances = (function() {
        var _k, _len1, _results;
        _results = [];
        for (_k = 0, _len1 = intersections.length; _k < _len1; _k++) {
          y = intersections[_k];
          _results.push(y.distance);
        }
        return _results;
      })();
      shortest_distance = Math.min.apply(null, distances);
      closest_object = (function() {
        var _k, _len1, _results;
        _results = [];
        for (_k = 0, _len1 = intersections.length; _k < _len1; _k++) {
          x = intersections[_k];
          if (x.distance === shortest_distance) {
            _results.push(x.object.id);
          }
        }
        return _results;
      })();
      if (closest_object.length > 0) {
        return closest_object[0];
      } else {
        return '';
      }
    };
    randomlySelectNewName = function(current_name) {
      var previous_name, triad_choice;
      previous_name = current_name;
      if (Math.random() < 0.5) {
        while (previous_name === current_name) {
          triad_choice = Math.floor(5.0 * Math.random());
          current_name = major_triad_names.black[triad_choice];
        }
      } else {
        while (previous_name === current_name) {
          triad_choice = Math.floor(7.0 * Math.random());
          current_name = major_triad_names.white[triad_choice];
        }
      }
      return current_name;
    };
    selectTriad = function() {
      scene.remove(current_triad_name);
      current_triad_name = randomlySelectNewName(current_triad_name);
      return scene.add(current_triad_name);
    };
    checkTriad = function(practice_chord) {
      var exists, name, played_triad_name, triad, _j, _k, _len, _len1, _ref, _ref1, _ref2;
      _ref = isValidMajorChord(practice_chord), exists = _ref[0], name = _ref[1];
      if (exists) {
        played_triad_name = null;
        _ref1 = major_triad_names.white;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          triad = _ref1[_j];
          if (triad.id === name[0]) {
            played_triad_name = triad;
          }
        }
        if (played_triad_name === null) {
          _ref2 = major_triad_names.black;
          for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
            triad = _ref2[_k];
            if (triad.id === name[0]) {
              played_triad_name = triad;
            }
          }
        }
        if (played_triad_name === current_triad_name) {
          playChord(practice_chord, 0.75);
          return true;
        }
      }
      playFail();
      return false;
    };
    isValidMajorChord = function(practice_chord) {
      var chord, chord_labels, index, note, _j, _k, _len, _len1;
      chord_labels = [];
      for (_j = 0, _len = practice_chord.length; _j < _len; _j++) {
        note = practice_chord[_j];
        chord_labels.push(getNoteLabel(note[0], note[1]).id);
      }
      for (index = _k = 0, _len1 = chords.length; _k < _len1; index = ++_k) {
        chord = chords[index];
        if (isSameChord(chord, chord_labels)) {
          return [true, chords[index]];
        }
      }
      return [false, []];
    };
    isSameChord = function(chord1, chord2) {
      var note, result, _j, _len;
      if (chord1.length !== chord2.length) {
        return false;
      }
      result = true;
      for (_j = 0, _len = chord1.length; _j < _len; _j++) {
        note = chord1[_j];
        result = result && (__indexOf.call(chord2, note) >= 0);
      }
      return result;
    };
    selectScaleDegree = function() {
      var degree_choice, previous_degree;
      scene.remove(current_scale_degree);
      previous_degree = current_scale_degree;
      while (previous_degree === current_scale_degree) {
        degree_choice = Math.floor(Math.random() * 9);
        current_scale_degree = scale_degree_names[degree_choice];
      }
      return scene.add(current_scale_degree);
    };
    checkScaleDegree = function(key_played) {
      var degree_selected, index, key_color, key_index, key_name, midi_start, note, _j, _len, _ref, _ref1;
      _ref = parseKeyObject(key_played), key_color = _ref[0], key_index = _ref[1];
      key_name = getNoteLabel(key_color, key_index);
      for (index = _j = 0, _len = current_scale.length; _j < _len; index = ++_j) {
        note = current_scale[index];
        if (note === key_name.id) {
          degree_selected = index + 1;
        }
      }
      if (degree_selected === current_scale_degree.id) {
        _ref1 = parseKeyObject(root_selected), key_color = _ref1[0], key_index = _ref1[1];
        midi_start = getMIDIkey(key_color, key_index);
        playScale(key_color, key_index);
        return selectScaleDegree();
      } else {
        return playFail();
      }
    };
    playNote = function(note, delay) {
      MIDI.noteOn(0, note, MIDI_keys.velocity - 20, delay);
      return setTimeout(function() {
        MIDI.noteOff(0, note, delay + 0.80);
        return MIDI_keys.velocity;
      });
    };
    playChord = function(notes, delay) {
      playNote(getMIDIkey(notes[0][0], notes[0][1]), delay);
      playNote(getMIDIkey(notes[1][0], notes[1][1]), delay);
      return playNote(getMIDIkey(notes[2][0], notes[2][1]), delay);
    };
    singAlong = function(song, volume) {
      var sound;
      sound = document.getElementById(song);
      sound.volumes = volume;
      return sound.play();
    };
    playQ = function() {
      return singAlong("q_song", 0.4);
    };
    playB = function() {
      return singAlong("b_song", 0.4);
    };
    playC = function() {
      return singAlong("ceg_song", 0.4);
    };
    playFail = function() {
      return singAlong("the_fail_song", 0.02);
    };
    animate = function() {
      window.requestAnimationFrame(animate) || window.webkitRequestAnimationFrame(animate);
      return render();
    };
    render = function() {
      return renderer.render(scene, camera);
    };
    mousedown = function(event) {
      key_played = getKeyPlayed(event);
      if (key_played !== '') {
        return pressKey(key_played, true);
      }
    };
    isActive = function(tabID) {
      if ($(tabID).attr("aria-expanded") === "true") {
        return true;
      }
      return false;
    };
    mouseup = function() {
      var key_color, key_index, practice_chord, _ref;
      if (key_played === '') {
        return;
      }
      if (isActive("#major_scale")) {
        if (root_selected === null) {
          root_selected = key_played;
          current_scale = generateScale(root_selected);
          selectScaleDegree();
        } else {
          checkScaleDegree(key_played);
        }
      }
      if (isActive("#practice")) {
        _ref = parseKeyObject(key_played), key_color = _ref[0], key_index = _ref[1];
        practice_keys.push([key_color, key_index]);
        if (practice_keys.length === 3) {
          if (checkTriad(practice_keys)) {
            selectTriad();
          }
          practice_keys = [];
          practice_chord = null;
        }
      }
      return releaseKey(key_played);
    };
    $('#keyboard').mouseover(function() {
      if (isActive("#practice")) {
        if (practice_keys.length === 0) {
          selectTriad();
        }
      }
      if (isActive("#major_scale")) {
        if (root_selected !== null) {
          return selectScaleDegree();
        }
      }
    });
    getObject = function(object) {
      var child, kb, ptr, _j, _k, _len, _len1, _ref, _ref1;
      _ref = scene.children;
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        child = _ref[_j];
        if (child.id === 'keyboard') {
          kb = child;
        }
      }
      if (object === 'keyboard') {
        return kb;
      }
      if (object === 'pointer') {
        _ref1 = kb.children;
        for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
          child = _ref1[_k];
          if (child.id === 'pointer') {
            ptr = child;
          }
        }
        return ptr;
      }
    };
    $('#keyboard').mouseout(function() {
      if (isActive("#major_scale")) {
        root_selected = null;
        current_scale = [];
        scene.remove(current_scale_degree);
        return current_scale_degree = null;
      }
    });
    $('#tabs').mouseover(function() {
      if (!isActive("#practice")) {
        return scene.remove(current_triad_name);
      }
    });
    q_song.addEventListener('mouseup', playQ, false);
    b_song.addEventListener('mouseup', playB, false);
    c_song.addEventListener('mouseup', playC, false);
    screen.addEventListener('mousedown', mousedown, false);
    screen.addEventListener('mouseup', mouseup, false);
    createScene();
    return animate();
  };
  playingKeyboard = null;
  MIDI.loadPlugin({
    soundfontUrl: "js/sound/soundfont/",
    instrument: ["acoustic_grand_piano"],
    callback: function() {
      playingKeyboard = new Keyboard();
      return MIDI.loader.stop();
    }
  });
  Event.add("body", "ready", function() {
    return MIDI.loader = new widgets.Loader("Loading keyboard...");
  });
  if (RUN_TESTS) {
    test("Canvas for keyboard", function() {
      return ok(document.getElementById('keyboard'), "Successfully constructed the keyboard");
    });
    return test("WebGL element for drawing", function() {
      return ok(screen, "WebGL enabled");
    });
  }
})();
